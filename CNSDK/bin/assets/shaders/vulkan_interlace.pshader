#define DEBUG_WHITE_VIEW 0

// Compatibility definitions to make HLSL/GLSL work with minimal changes
#if USE_HLSL == 1

#define uniform /**/
#define highp /**/

#define InTexCoord input.TexCoord
#define InScreenTexCoord input.ScreenTexCoord

#else

#if MEDIUM_P
precision mediump float;
#else
precision highp float;
#endif

#define float2 vec2
#define float3 vec3
#define float4 vec4
#define float4x4 mat4
#define fmod mod
#define lerp mix

#define InTexCoord TexCoord
#define InScreenTexCoord ScreenTexCoord

#endif

// Shader input/output signatures
#if USE_HLSL == 1

struct VSInput
{
    float3 Pos : POSITION;
    float3 Col : COLOR;
    float2 Tex : TEXCOORD;
};

struct PSInput
{
    float4               Pos            : SV_POSITION;
    noperspective float2 TexCoord       : TEXCOORD;
    noperspective float2 ScreenTexCoord : TEXCOORD2;
};

#else

layout(location = 0) in highp vec2 TexCoord;
layout(location = 1) in highp vec2 ScreenTexCoord;

layout(location = 0) out highp vec4 FragColor;

#endif

// Shader texture inputs
#if USE_HLSL == 1

#if defined(INDIVIDUAL_VIEWS) || defined(STEREO_INDIVIDUAL_VIEWS)
    Texture2DArray viewTextureArray : register(t0);
#else
    Texture2D viewTexture : register(t0);
#endif

SamplerState viewSampler : register(s0);

#else

#ifdef USE_VIDEO_TEXTURE_FOR_VIEWS
layout(binding = 1) uniform samplerExternalOES viewTexture;
#else
layout(binding = 1) uniform sampler2D viewTexture[12];
#endif

#endif

// Global variables (uniforms for GLSL and constant buffer for HLSL)
#if USE_HLSL == 1
cbuffer LeiaInterlaceShaderConstantBufferData : register(b0)
{
#else
layout(binding = 0) uniform UniformBufferObject
{
#endif

    //Must have 16 byte padding
     float  hardwareViewsX;
     float  hardwareViewsY;
     float  viewResX;
     float  viewResY;

     highp float  viewportX;
     highp float  viewportY;
     highp float  viewportWidth;
     highp float  viewportHeight;

     float  minView;
     float  maxView;
     highp float  n;
     highp float  d_over_n;

     highp float  p_over_du;
     highp float  p_over_dv;
     float  colorSlant;
     float  colorInversion;

     highp float  faceX;
     highp float  faceY;
     highp float  faceZ;
     highp float  pixelPitch;

     highp float  du;
     highp float  dv;
     highp float  s;
     highp float  cos_theta;

     highp float  sin_theta;
     highp float  peelOffset;
     highp float  No;
     float  displayResX;

     float  displayResY;
     float  blendViews;
     int    interlaceMode;
     int    debugMode;

     int    perPixelCorrection;
     int    viewTextureType;
     float  reconvergenceAmount;
     float  softwareViews;

     highp float  absReconvergenceAmount;
     highp float  alpha;
     float  padding1;
     float  padding2;

     highp float4x4 textureTransform;

     highp float4x4 rectTransform;

     highp float customTextureScaleX;
     highp float customTextureScaleY;
     highp float reconvergenceZoomX;
     highp float reconvergenceZoomY;
    //Must have 16 byte padding

#if USE_HLSL == 1
};
#else
} ubo;
#endif

float4 sampleTexture(int viewIndex, float2 uv)
{
#if USE_HLSL == 1

#if defined(INDIVIDUAL_VIEWS) || defined(STEREO_INDIVIDUAL_VIEWS)
    float4 color = viewTextureArray.Sample(viewSampler, float3(uv, viewIndex));
#else
    float4 color = viewTexture.Sample(viewSampler, uv);
#endif

#else

#ifdef USE_VIDEO_TEXTURE_FOR_VIEWS
    float4 color = texture(viewTexture, uv);
#else
    float4 color = texture(viewTexture[viewIndex], uv);
#endif

#endif

    return color;
}

float4 debugSampleAllTextures(float2 uv, int rows, int cols)
{
    int col = int(uv.x * float(cols));
    int row = int(uv.y * float(rows));
    float u = (uv.x - float(col / cols)) * float(cols);
    float v = (uv.y - float(row / rows)) * float(rows);
    int viewIndex = row*cols+col;
    return sampleTexture(viewIndex, float2(u,v));
}

highp float3 periodic_mod(highp float3 a, highp float3 b)
{
    return a - b * floor(a / b);
}

highp float N(highp float x, highp float y, highp float z, highp float x0, highp float y0)
{
    highp float dx     = ubo.s*x0 + (ubo.cos_theta-1.0)*x0 - ubo.sin_theta*y0;
    highp float dy     = ubo.s*y0 + (ubo.cos_theta-1.0)*y0 + ubo.sin_theta*x0;
    highp float denom  = sqrt(z*z + (1.0 - 1.0/(ubo.n*ubo.n))*((x-x0)*(x-x0) + (y-y0)*(y-y0)));
    highp float u      = dx + ubo.d_over_n*(x-x0)/denom;
    highp float v      = dy + ubo.d_over_n*(y-y0)/denom;
    highp float result = u/ ubo.du + v/ ubo.dv;
    return ubo.No + result;
}

float4 sampleDebugStereoTexture(float2 uv, int viewIndex)
{
    float u = ((float(viewIndex) < (ubo.hardwareViewsX/2.0)) ? 0.0 : 0.5) + (uv.x * 0.5);
    float v = uv.y;
    return sampleTexture(0, float2(u,v));
}

float4 sampleDebugThumbnailTexture(float2 uv, int viewIndex)
{
    //leaving for reference
    //uv += float2(tilex[viewIndex].x, tiley[viewIndex].x);
    return sampleTexture(0, uv);
}

float4 sampleDebugCalibrationTexture(float2 uv, int viewIndex)
{
         if (viewIndex == 0)  return sampleTexture(0, float2(0.0,   0.75) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 1)  return sampleTexture(0, float2(0.333, 0.75) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 2)  return sampleTexture(0, float2(0.666, 0.75) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 3)  return sampleTexture(0, float2(0.0,   0.5)  + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 4)  return sampleTexture(0, float2(0.333, 0.5)  + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 5)  return sampleTexture(0, float2(0.666, 0.5)  + float2(0.333, 0.25) * uv.xy);  
    else if (viewIndex == 6)  return sampleTexture(0, float2(0.0,   0.25) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 7)  return sampleTexture(0, float2(0.333, 0.25) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 8)  return sampleTexture(0, float2(0.666, 0.25) + float2(0.333, 0.25) * uv.xy);  
    else if (viewIndex == 9)  return sampleTexture(0, float2(0.0,   0.0)  + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 10) return sampleTexture(0, float2(0.333, 0.0)  + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 11) return sampleTexture(0, float2(0.666, 0.0)  + float2(0.333, 0.25) * uv.xy);    
    return float4(0,0,0,1); 
}

float4 sample_view(float2 uv, int viewIndex) 
{
//if (viewIndex < minView || viewIndex > maxView)
//  return float4(0.0,0.0,0.0,1.0);

#if DEBUG_WHITE_VIEW //debug first view white, rest black
    if(viewIndex == 0)
    {
        return float4(1.0,1.0,1.0,1.0);
    }
    else
    {
        return float4(0.0,0.0,0.0,1.0);
    }
#endif 

    float actualSoftwareView = floor(float(viewIndex) / ubo.hardwareViewsX * ubo.softwareViews);

#if ENABLE_RECONVERGENCE == 1

    // Idea: Input reconvergenceAmount value expressed in fraction of image width
    //       - translate left image by 0.5*reconv | right image by -0.5*reconv (noZoom)
    //       - OPTIONAL: apply x-scaling to avoid de-occlusions on sides (zoomX)
    //       - OPTIONAL: apply additional y-scaling to conserve image aspect ratio (zoomXY)

    float isLeft = actualSoftwareView; // Careful we want more L than R when numView is odd

    uv.x = (1.0 - ubo.reconvergenceZoomX * ubo.absReconvergenceAmount) * (uv.x - 0.5) + 0.5 + 0.5 * (2.0 * isLeft - 1.0) * ubo.reconvergenceAmount; // zoom in x only

    uv.y = (1.0 - ubo.reconvergenceZoomY * ubo.absReconvergenceAmount) * (uv.y - 0.5) + 0.5; // uncomment to add zoom in y direction to conserve image aspect ratio
#endif

#ifdef SHOW_CALIBRATION_IMAGE

    // Show calibration image.
    return sampleDebugCalibrationTexture(uv, viewIndex);

#elif defined(SHOW_STEREO_IMAGE)

    // Show stereo image.
    return sampleDebugStereoTexture(uv, viewIndex);

#elif defined(SHOW_THUMBNAILS)

    // Show thumbnail
    return sampleDebugThumbnailTexture(uv, viewIndex);

#elif defined(STEREO_INDIVIDUAL_VIEWS)

    // A pair of individual left/right views.
    return sampleTexture(float(viewIndex) < (ubo.hardwareViewsX/2.0) ? 0 : 1, uv);

#elif defined(STEREO_ATLAS_VIEWS)

    // Texture atlas of side-by-side left/right views.
    float u = ((float(viewIndex) < (ubo.hardwareViewsX/2.0)) ? 0.0 : 0.5) + (uv.x * 0.5);
    float v = uv.y;
    return sampleTexture(0, float2(u,v));

#elif defined(INDIVIDUAL_VIEWS)

    // Individual views.
    return sampleTexture(viewIndex, uv);

#elif defined(ATLAS_VIEWS)

    float xTextureScale = ubo.textureTransform[0][0];
    float yTextureScale = ubo.textureTransform[1][1];

#if SINGLE_VIEW_MODE == 1
    actualSoftwareView = 0.0;
#endif

    //Quick support for nx1 & 1xn view sources
#if HORIZONTAL_SOURCE_VIEWS == 1
    float viewScale = (1.0 / ubo.softwareViews) * ubo.customTextureScaleX;
    uv.x = (uv.x * viewScale) + (actualSoftwareView * viewScale);
    uv.y *= ubo.customTextureScaleY;
#else
    float viewScale = (1.0 / ubo.softwareViews) * ubo.customTextureScaleY;
    uv.y = (uv.y * viewScale) + (actualSoftwareView * viewScale);
    uv.x *= ubo.customTextureScaleX;
#endif

    return sampleTexture(0, uv);

#endif

    return float4(0.0, 0.0, 0.0, 0.0);
}

float4 sample_view(float2 uv, float view)
{
    //if (blendViews == 0.0)
        //return sample_view(uv, int(view));

    float black_point    = 0.0;
    float white_point    = 1.0;
    float view1          = fmod(floor(view), ubo.hardwareViewsX);
    float view2          = fmod(floor(view1 + 1.1), ubo.hardwareViewsX);
    float linear_mix     = (view - view1);
    float non_linear_mix = smoothstep(black_point, white_point, linear_mix);
    float4 a             = sample_view(uv, int(view1));
    float4 b             = sample_view(uv, int(view2));

    return lerp(a, b, non_linear_mix * ubo.blendViews);
}

highp float3 calculateViewVector(highp float2 uv)
{
    highp float3 views;

    highp float baseView = (ubo.p_over_du * ubo.displayResX * uv.x) + (ubo.p_over_dv * ubo.displayResY * uv.y) + fmod(ubo.colorSlant * ubo.displayResY * uv.y, ubo.p_over_du);
    views.r = baseView;
    views.g = baseView;
    views.b = baseView;

    views.r += 2.0 * ubo.colorInversion;
    views.g += 1.0;
    views.b += 2.0 * (1.0 - ubo.colorInversion);

    return views;
}

highp float3 calculateViewIndices(highp float2 normalized_display_coord)
{
    highp float3 viewVector = calculateViewVector(normalized_display_coord);

    highp float viewCount = ubo.hardwareViewsX * ubo.hardwareViewsY;
    // correct some float precision issues with this offset
    highp float correction = - 1.0 / max(2.0, viewCount);

    highp float float_precision_offset = 0.0;
    
    //#if DirectX set offset to 0
    highp float user_offset =  0.0;

#if DEBUG_WHITE_VIEW
     // we want todo no PPC!
#else

    #if PIXELCORRECTION == 1 // View peeling
            float x0 = (normalized_display_coord.x - 0.5) * ubo.displayResX * ubo.pixelPitch;
         //there is a strong likelyhood this is all we need and the #define was being used multiple times incorrectly, lee & cyrus to verify
            float y0 = (normalized_display_coord.y - 0.5) * ubo.displayResY * ubo.pixelPitch;

                float dN = N(ubo.faceX, ubo.faceY, ubo.faceZ, 0.0, 0.0) - N(ubo.faceX, ubo.faceY, ubo.faceZ, x0, y0);
                user_offset += (viewCount - 1.0) * 0.5 - ubo.No;
                user_offset -= ubo.peelOffset;
                user_offset += dN;
    #elif PIXELCORRECTION == 2 // stereo sliding
         highp float x0 = (normalized_display_coord.x - 0.5) * ubo.displayResX * ubo.pixelPitch;
    
         //there is a strong likelyhood this is all we need and the #define was being used multiple times incorrectly, lee & cyrus to verify
         highp float y0 = (normalized_display_coord.y - 0.5) * ubo.displayResY * ubo.pixelPitch;
         user_offset += (viewCount - fmod(viewCount + 1.0, 2.0)) * 0.5 - N(ubo.faceX, ubo.faceY, ubo.faceZ, x0, y0);
    #endif

#endif

    user_offset -= ubo.p_over_dv*(ubo.displayResY-1.0);

    // last row / row "3" of viewMatrix is ith view index,
    highp float3 views = periodic_mod(viewVector + user_offset + float_precision_offset, float3(viewCount, viewCount, viewCount));

    return views;
}

#if USE_HLSL == 1
float4 main(PSInput input) : SV_Target0
#else
void main()
#endif
{
    highp float2 texture_offset = float2(0.5, 0.5) / float2(ubo.displayResX, ubo.displayResY);
    highp float2  uv = InScreenTexCoord;
    highp float u0 = float(ubo.viewportX)/ float(ubo.displayResX);
    highp float v0 = float(ubo.viewportY)/ float(ubo.displayResY);
    highp float u1 = float(ubo.viewportX+ ubo.viewportWidth)/ float(ubo.displayResX);
    highp float v1 = float(ubo.viewportY+ ubo.viewportHeight)/ float(ubo.displayResY);
    uv = lerp(float2(u0, v0), float2(u1, v1), uv);
    highp float2 normalized_display_coord = uv - texture_offset;

    highp float3 viewIndices = calculateViewIndices(normalized_display_coord);

    highp float4 interlaced_fragment;

    normalized_display_coord = InTexCoord - texture_offset;

    interlaced_fragment[0] = sample_view(normalized_display_coord, viewIndices[0]).r;
    interlaced_fragment[1] = sample_view(normalized_display_coord, viewIndices[1]).g;
    interlaced_fragment[2] = sample_view(normalized_display_coord, viewIndices[2]).b;
    interlaced_fragment[3] = ubo.alpha;

    float4 retColor  = interlaced_fragment; 

#if defined(SHOW_TEXTURE_COORDINATES)
    retColor = float4(InTexCoord.x, InTexCoord.y, 0.0, 1.0); // Show texture coordinates
#elif defined(SHOW_ALL_VIEWS)
    retColor = debugSampleAllTextures(InTexCoord, 3, 4);   // Show all textures
#elif defined(SHOW_FIRST_VIEW)
    retColor = sampleTexture(0, InTexCoord);        // Show first texture
#endif

#if USE_HLSL == 1
    return retColor;
#else
    FragColor = retColor;
#endif
}