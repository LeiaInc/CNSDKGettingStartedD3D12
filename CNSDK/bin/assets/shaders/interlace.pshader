#define DEBUG_WHITE_VIEW 0

// Compatibility definitions to make HLSL/GLSL work with minimal changes
#if USE_HLSL == 1

#define uniform /**/
#define highp /**/
#define gv(x) x

#define InTexCoord input.TexCoord
#define InScreenTexCoord input.ScreenTexCoord

#else

#if MEDIUM_P
precision mediump float;
#else
precision highp float;
#endif

#if USE_GLSL_VULKAN
#define gv(x) ubo.x
#define LAYOUTLOC(x) layout(location = x)
#define LAYOUTBIND(x) layout(binding = x)
#else
#define gv(x) x
#define LAYOUTLOC(x) /**/
#define LAYOUTBIND(x) /**/
#endif

#define float2 vec2
#define float3 vec3
#define float4 vec4
#define float4x4 mat4
#define fmod mod
#define lerp mix

#define InTexCoord TexCoord
#define InScreenTexCoord ScreenTexCoord

#endif

// Shader input/output signatures
#if USE_HLSL == 1

struct VSInput
{
    float3 Pos : POSITION;
    float3 Col : COLOR;
    float2 Tex : TEXCOORD;
};

struct PSInput
{
    float4               Pos            : SV_POSITION;
    noperspective float2 TexCoord       : TEXCOORD;
    noperspective float2 ScreenTexCoord : TEXCOORD2;
};

#else

LAYOUTLOC(0) in highp vec2 TexCoord;
LAYOUTLOC(1) in highp vec2 ScreenTexCoord;

LAYOUTLOC(0) out highp vec4 FragColor;

#endif

// Shader texture inputs
#if USE_HLSL == 1

#if defined(INDIVIDUAL_VIEWS) || defined(STEREO_INDIVIDUAL_VIEWS)
    Texture2DArray viewTextureArray : register(t0);
#else
    Texture2D viewTexture : register(t0);
#endif

SamplerState viewSampler : register(s0);

#else

#ifdef USE_VIDEO_TEXTURE_FOR_VIEWS
LAYOUTBIND(1) uniform samplerExternalOES viewTexture;
#else
LAYOUTBIND(1) uniform sampler2D viewTexture[12];
#endif

#endif

// Global variables (uniforms for GLSL and constant buffer for HLSL)
#if USE_HLSL == 1
cbuffer LeiaInterlaceShaderConstantBufferData : register(b0)
{
#elif USE_GLSL_VULKAN == 1
LAYOUTBIND(0) uniform UniformBufferObject
{
#endif

    //Must have 16 byte padding
    uniform float  hardwareViewsX;
    uniform float  hardwareViewsY;
    uniform float  viewResX;
    uniform float  viewResY;

    uniform highp float  viewportX;
    uniform highp float  viewportY;
    uniform highp float  viewportWidth;
    uniform highp float  viewportHeight;

    uniform float  minView;
    uniform float  maxView;
    uniform highp float  n;
    uniform highp float  d_over_n;

    uniform highp float  p_over_du;
    uniform highp float  p_over_dv;
    uniform float  colorSlant;
    uniform float  colorInversion;

    uniform highp float  faceX;
    uniform highp float  faceY;
    uniform highp float  faceZ;
    uniform highp float  pixelPitch;

    uniform highp float  du;
    uniform highp float  dv;
    uniform highp float  s;
    uniform highp float  cos_theta;

    uniform highp float  sin_theta;
    uniform highp float  peelOffset;
    uniform highp float  No;
    uniform float  displayResX;

    uniform float  displayResY;
    uniform float  blendViews;
    uniform int    interlaceMode;
    uniform int    debugMode;

    uniform int    perPixelCorrection;
    uniform int    viewTextureType;
    uniform float  reconvergenceAmount;
    uniform float  softwareViews;

    uniform highp float  absReconvergenceAmount;
    uniform highp float  alpha;
    uniform float  padding1;
    uniform float  padding2;

    uniform highp float4x4 textureTransform;

    uniform highp float4x4 rectTransform;

    uniform highp float customTextureScaleX;
    uniform highp float customTextureScaleY;
    uniform highp float reconvergenceZoomX;
    uniform highp float reconvergenceZoomY;

#if  SP_ACT == 1
    uniform float ACT_gamma;
    uniform float ACT_invGamma;
    uniform float ACT_singletap_coef;
    uniform float ACT_norm;
#endif

#if USE_HLSL == 1
};
#elif USE_GLSL_VULKAN == 1
} ubo;
#endif

float4 sampleTexture(int viewIndex, float2 uv)
{
#if USE_HLSL == 1

#if defined(INDIVIDUAL_VIEWS) || defined(STEREO_INDIVIDUAL_VIEWS)
    float4 color = viewTextureArray.Sample(viewSampler, float3(uv, viewIndex));
#else
    float4 color = viewTexture.Sample(viewSampler, uv);
#endif

#else

#ifdef USE_VIDEO_TEXTURE_FOR_VIEWS
    float4 color = texture(viewTexture, uv);
#else
    float4 color = texture(viewTexture[viewIndex], uv);
#endif

#endif

    return color;
}

float4 debugSampleAllTextures(float2 uv, int rows, int cols)
{
    int col = int(uv.x * float(cols));
    int row = int(uv.y * float(rows));
    float u = (uv.x - float(col / cols)) * float(cols);
    float v = (uv.y - float(row / rows)) * float(rows);
    int viewIndex = row * cols + col;
    return sampleTexture(viewIndex, float2(u, v));
}

highp float3 periodic_mod(highp float3 a, highp float3 b)
{
    return a - b * floor(a / b);
}

highp float N(highp float x, highp float y, highp float z, highp float x0, highp float y0)
{
    highp float dx = gv(s) * x0 + (gv(cos_theta) - 1.0) * x0 - gv(sin_theta) * y0;
    highp float dy = gv(s) * y0 + (gv(cos_theta) - 1.0) * y0 + gv(sin_theta) * x0;
    highp float denom = sqrt(z * z + (1.0 - 1.0 / (gv(n) * gv(n))) * ((x - x0) * (x - x0) + (y - y0) * (y - y0)));
    highp float u = dx + gv(d_over_n) * (x - x0) / denom;
    highp float v = dy + gv(d_over_n) * (y - y0) / denom;
    highp float result = u / gv(du) + v / gv(dv);
    return gv(No) + result;
}

float4 sampleDebugStereoTexture(float2 uv, int viewIndex)
{
    float u = ((float(viewIndex) < (gv(hardwareViewsX) / 2.0)) ? 0.0 : 0.5) + (uv.x * 0.5);
    float v = uv.y;
    return sampleTexture(0, float2(u, v));
}

float4 sampleDebugThumbnailTexture(float2 uv, int viewIndex)
{
    //leaving for reference
    //uv += float2(tilex[viewIndex].x, tiley[viewIndex].x);
    return sampleTexture(0, uv);
}

float4 sampleDebugCalibrationTexture(float2 uv, int viewIndex)
{
    if (viewIndex == 0)  return sampleTexture(0, float2(0.0, 0.75) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 1)  return sampleTexture(0, float2(0.333, 0.75) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 2)  return sampleTexture(0, float2(0.666, 0.75) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 3)  return sampleTexture(0, float2(0.0, 0.5) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 4)  return sampleTexture(0, float2(0.333, 0.5) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 5)  return sampleTexture(0, float2(0.666, 0.5) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 6)  return sampleTexture(0, float2(0.0, 0.25) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 7)  return sampleTexture(0, float2(0.333, 0.25) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 8)  return sampleTexture(0, float2(0.666, 0.25) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 9)  return sampleTexture(0, float2(0.0, 0.0) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 10) return sampleTexture(0, float2(0.333, 0.0) + float2(0.333, 0.25) * uv.xy);
    else if (viewIndex == 11) return sampleTexture(0, float2(0.666, 0.0) + float2(0.333, 0.25) * uv.xy);
    return float4(0, 0, 0, 1);
}

float4 sample_view(float2 uv, int viewIndex)
{
    //if (viewIndex < minView || viewIndex > maxView)
    //  return float4(0.0,0.0,0.0,1.0);

#if DEBUG_WHITE_VIEW //debug first view white, rest black
    if (viewIndex == 0)
    {
        return float4(1.0, 1.0, 1.0, 1.0);
    }
    else
    {
        return float4(0.0, 0.0, 0.0, 1.0);
    }
#endif 

    float actualSoftwareView = floor(float(viewIndex) / gv(hardwareViewsX) * gv(softwareViews));

#if ENABLE_RECONVERGENCE == 1

    // Idea: Input reconvergenceAmount value expressed in fraction of image width
    //       - translate left image by 0.5*reconv | right image by -0.5*reconv (noZoom)
    //       - OPTIONAL: apply x-scaling to avoid de-occlusions on sides (zoomX)
    //       - OPTIONAL: apply additional y-scaling to conserve image aspect ratio (zoomXY)

    float isLeft = actualSoftwareView;
    uv.x = (1.0 - gv(reconvergenceZoomX) * gv(absReconvergenceAmount)) * (uv.x - 0.5) + 0.5 + 0.5 * (2.0 * isLeft - 1.0) * gv(reconvergenceAmount); // zoom in x only
    uv.y = (1.0 - gv(reconvergenceZoomY) * gv(absReconvergenceAmount)) * (uv.y - 0.5) + 0.5; // uncomment to add zoom in y direction to conserve image aspect ratio
#endif

#ifdef SHOW_CALIBRATION_IMAGE

    // Show calibration image.
    return sampleDebugCalibrationTexture(uv, viewIndex);

#elif defined(SHOW_STEREO_IMAGE)

    // Show stereo image.
    return sampleDebugStereoTexture(uv, viewIndex);

#elif defined(SHOW_THUMBNAILS)

    // Show thumbnail
    return sampleDebugThumbnailTexture(uv, viewIndex);

#elif defined(STEREO_INDIVIDUAL_VIEWS)

    // A pair of individual left/right views.
    return sampleTexture(float(viewIndex) < (gv(hardwareViewsX) / 2.0) ? 0 : 1, uv);

#elif defined(STEREO_ATLAS_VIEWS)

    // Texture atlas of side-by-side left/right views.
    float u = ((float(viewIndex) < (gv(hardwareViewsX) / 2.0)) ? 0.0 : 0.5) + (uv.x * 0.5);
    float v = uv.y;
    return sampleTexture(0, float2(u, v));

#elif defined(INDIVIDUAL_VIEWS)

    // Individual views.
    return sampleTexture(viewIndex, uv);

#elif defined(ATLAS_VIEWS)

    float xTextureScale = gv(textureTransform[0][0]);
    float yTextureScale = gv(textureTransform[1][1]);

#if SINGLE_VIEW_MODE == 1
    actualSoftwareView = 0.0;
#endif

    //Quick support for nx1 & 1xn view sources
#if HORIZONTAL_SOURCE_VIEWS == 1
    float viewScale = (1.0 / gv(softwareViews)) * gv(customTextureScaleX);
    uv.x = (uv.x * viewScale) + (actualSoftwareView * viewScale);
    uv.y *= gv(customTextureScaleY);
#else
    float viewScale = (1.0 / gv(softwareViews)) * gv(customTextureScaleY);
    uv.y = (uv.y * viewScale) + (actualSoftwareView * viewScale);
    uv.x *= gv(customTextureScaleX);
#endif

    return sampleTexture(0, uv);

#endif

    return float4(0.0, 0.0, 0.0, 0.0);
}

#if  SP_ACT == 1

vec3 GammaToLinear(vec4 col)
{
    //Driver bug with android video textures that creates artifacts if any value of col is negative
#if defined(USE_VIDEO_TEXTURE_FOR_VIEWS) && (USE_HLSL == 0)
    col = max(col, 0.0);
#endif

    return vec3(pow(col.r, ACT_gamma), pow(col.g, ACT_gamma), pow(col.b, ACT_gamma));
}

vec4 LinearToGamma(vec4 col)
{
    return vec4(pow(col.r, ACT_invGamma), pow(col.g, ACT_invGamma), pow(col.b, ACT_invGamma), col.a);
}
#endif

float4 sample_view(float2 uv, float view)
{
    //if (blendViews == 0.0)
        //return sample_view(uv, int(view));

    float black_point = 0.0;
    float white_point = 1.0;
    float view1 = fmod(floor(view), gv(hardwareViewsX));
    float view2 = fmod(floor(view1 + 1.1), gv(hardwareViewsX));
    float linear_mix = (view - view1);
    float non_linear_mix = smoothstep(black_point, white_point, linear_mix);

#if  SP_ACT == 0
    float4 a = sample_view(uv, int(view1));
    float4 b = sample_view(uv, int(view2));

    return lerp(a, b, non_linear_mix * gv(blendViews));
#else
    vec4 a = vec4(0.0, 0.0, 0.0, 1.0);
    a.rgb += GammaToLinear(sample_view(uv, int(view1)));
    a.rgb -= ACT_singletap_coef * GammaToLinear(sample_view(uv, int(mod(view1 + (floor(gv(hardwareViewsX) / 2.0)), gv(hardwareViewsX)))));
    a.rgb *= ACT_norm;

    vec4 b = vec4(0.0, 0.0, 0.0, 1.0);
    b.rgb += GammaToLinear(sample_view(uv, int(view2)));
    b.rgb -= ACT_singletap_coef * GammaToLinear(sample_view(uv, int(mod(view2 - (floor(gv(hardwareViewsX) / 2.0)), gv(hardwareViewsX)))));
    b.rgb *= ACT_norm;

    return LinearToGamma(clamp(mix(a, b, non_linear_mix * gv(blendViews)), 0.0, 1.0));

#endif

}

highp float3 calculateViewVector(highp float2 uv)
{
    highp float3 views;

    highp float baseView = (gv(p_over_du) * gv(displayResX) * uv.x) + (gv(p_over_dv) * gv(displayResY) * uv.y) + fmod(gv(colorSlant) * gv(displayResY) * uv.y, gv(p_over_du));
    views.r = baseView;
    views.g = baseView;
    views.b = baseView;

    views.r += 2.0 * gv(colorInversion);
    views.g += 1.0;
    views.b += 2.0 * (1.0 - gv(colorInversion));

    return views;
}

highp float3 calculateViewIndices(highp float2 normalized_display_coord)
{
    highp float3 viewVector = calculateViewVector(normalized_display_coord);

    highp float viewCount = gv(hardwareViewsX) * gv(hardwareViewsY);
    // correct some float precision issues with this offset
    highp float correction = -1.0 / max(2.0, viewCount);

    highp float float_precision_offset = 0.0;

    //#if DirectX set offset to 0
    highp float user_offset = 0.0;

#if DEBUG_WHITE_VIEW
    // we want todo no PPC!
#else
    highp float top = gv(displayResY) - gv(viewportHeight) - gv(viewportY);

#if PIXELCORRECTION == 1 // View peeling
    highp float x0 = (normalized_display_coord.x * gv(viewportWidth) + gv(viewportX) - 0.5 * gv(displayResX)) * gv(pixelPitch);

    //there is a strong likelihood this is all we need and the #define was being used multiple times incorrectly, lee & cyrus to verify
    highp float y0 = (normalized_display_coord.y * gv(viewportHeight) - gv(viewportHeight) - top + 0.5 * gv(displayResY)) * gv(pixelPitch);

    float dN = N(gv(faceX), gv(faceY), gv(faceZ), 0.0, 0.0) - N(gv(faceX), gv(faceY), gv(faceZ), x0, y0);
    user_offset += (viewCount - 1.0) * 0.5 - gv(No);
    user_offset -= peelOffset;
    user_offset += dN;
#elif PIXELCORRECTION == 2 // stereo sliding
    highp float x0 = (normalized_display_coord.x * gv(viewportWidth) + gv(viewportX) - 0.5 * gv(displayResX)) * gv(pixelPitch);

    // there is a strong likelihood this is all we need and the #define was being used multiple times incorrectly, lee & cyrus to verify
    highp float y0 = (normalized_display_coord.y * gv(viewportHeight) - gv(viewportHeight) - top + 0.5 * gv(displayResY)) * gv(pixelPitch);
    user_offset += (viewCount - fmod(viewCount + 1.0, 2.0)) * 0.5 - N(gv(faceX), gv(faceY), gv(faceZ), x0, y0);
#endif

#endif

    user_offset -= gv(p_over_dv) * (gv(displayResY) - 1.0);

    // last row / row "3" of viewMatrix is ith view index,
    highp float3 views = periodic_mod(viewVector + user_offset + float_precision_offset, float3(viewCount, viewCount, viewCount));

    return views;
}

#if USE_HLSL == 1
float4 main(PSInput input) : SV_Target0
#else
void main()
#endif
{
    highp float2 texture_offset = float2(0.5, 0.5) / float2(gv(displayResX), gv(displayResY));
    highp float2  uv = InScreenTexCoord;
    highp float u0 = float(gv(viewportX)) / float(gv(displayResX));
    highp float v0 = float(gv(viewportY)) / float(gv(displayResY));
    highp float u1 = float(gv(viewportX) + gv(viewportWidth)) / float(gv(displayResX));
    highp float v1 = float(gv(viewportY) + gv(viewportHeight)) / float(gv(displayResY));
    uv = lerp(float2(u0, v0), float2(u1, v1), uv);
    highp float2 normalized_display_coord = uv - texture_offset;

    highp float3 viewIndices = calculateViewIndices(normalized_display_coord);

    highp float4 interlaced_fragment;

    normalized_display_coord = InTexCoord - texture_offset;

    interlaced_fragment[0] = sample_view(normalized_display_coord, viewIndices[0]).r;
    interlaced_fragment[1] = sample_view(normalized_display_coord, viewIndices[1]).g;
    interlaced_fragment[2] = sample_view(normalized_display_coord, viewIndices[2]).b;
    interlaced_fragment[3] = gv(alpha);

    float4 retColor = interlaced_fragment;

#if defined(SHOW_TEXTURE_COORDINATES)
    retColor = float4(InTexCoord.x, InTexCoord.y, 0.0, 1.0); // Show texture coordinates
#elif defined(SHOW_ALL_VIEWS)
    retColor = debugSampleAllTextures(InTexCoord, 3, 4);   // Show all textures
#elif defined(SHOW_FIRST_VIEW)
    retColor = sampleTexture(0, InTexCoord);        // Show first texture
#endif

#if USE_HLSL == 1
    return retColor;
#else
    FragColor = retColor;
#endif
}
